<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="Style.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <script src="https://unpkg.com/docx@7.8.2/build/index.js"></script>
    <link rel="icon" href="./logo.JPG" type="image/x-icon">

    <title>Production Test Records</title>
    <style>
        /* Add your existing table styles here */
        #HEADING_1 {
            text-align: center;
        }


        input#filter-input {
            padding: 20px !important;
            font-size: 15px;
        }

        .thumbnail {
            max-width: 100px;
            cursor: pointer;
        }

        #imageModal {
            display: none;
            position: fixed;
            /*...*/
        }

        body {
            background: none;
        }

        #testRecords {
            width: 100%;
            border-collapse: collapse;
        }

        #testRecords th,
        #testRecords td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        #testRecords th {
            background-color: lightblue;
            text-align: left;
            border: 1px solid black;
        }

        #testRecords td {
            text-align: left;
            border: 1px solid black;
        }



        .pdf-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .pdf-link {
            color: #0066cc;
            text-decoration: none;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .pdf-link:hover {
            background-color: #f0f7ff;
            text-decoration: underline;
        }


        a.nav-btn {
            text-decoration: none !important;
        }

        a.nav-btn:hover {
            color: orange;
        }

        .pdf-size {
            font-size: 0.8em;
            color: #666;
        }

        .pdf-upload {
            font-size: 0.9em;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
        }


        .filter-container {
            margin-bottom: 15px;
        }

        .filter-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #filter-column,
        #filter-input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .clear-filters {
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .clear-filters:hover {
            background-color: #d32f2f;
        }


        .pdf-refresh {
            background: none;
            border: none;
            color: #0066cc;
            cursor: pointer;
            margin-left: 8px;
            padding: 2px;
        }

        .pdf-refresh:hover {
            color: #004499;
        }

        .pdf-container {
            display: flex;
            align-items: center;
        }

        #testRecords {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
        }

        #testRecords th {
            background-color: #003865 !important;
            color: white;
            padding: 10px;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        #testRecords td {
            padding: 10px;
            border: 1px solid black;
        }

        
        #download-report {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        #download-report:hover {
            background-color: #45a049;
        }

        button.edit-row-btn {
            color: white;
        }

        

        .row-edited {
           /* background-color: lightgrey !important;*/
            /* Soft yellow */
            transition: background-color 0.6s;
            color:red;
            border:2px solid red;
            background:beige;
        }

        .testhdr{
            padding: 30px !important;
        }
    </style>
</head>

<body>
    <header class="testhdr">
        <div class="logo">
            <img src="logo-minew.png" alt="" class="imglogo">
        </div>
        <div class="headr">Master Instruments</div>
        <div id="usericon">
            <img src="profile.png" alt="">
            <div id="user-info" style="text-align: right; font-size: 14px; margin-right: 20px;"></div>
        </div>
    </header>

    <nav class="nav">
        <a href="layout.html" class="nav-btn"> Back to Home</a>
    </nav>
    <h1 id="HEADING_1">Production Test Records</h1>

    <div class="filter-container" id="filterContainer">
        <div class="filter-controls">
            <select id="filter-column">
                <option value="all">All Columns</option>
                <option value="1">DATE</option>
                <option value="2">PN</option>
                <option value="3">DRAW NO</option>
                <option value="4">No/Cell</option>
                <option value="5">CUSTOMER</option>
                <option value="6">QTY</option>
                <option value="7">AV</option>
                <option value="8">ESTIMATED TIME</option>
                <option value="9">TOTAL HOURS WORKED</option>
                <option value="10">UNIT PRICE</option>
                <option value="11">REMAINING TIME</option>
                <option value="12">TEST TIME</option>
                <option value="13">ORDER NO</option>
                <option value="14">BILL PRICE</option>
                <option value="15">PROFIT</option>
                <option value="16">STOCK CODE</option>
                <option value="17">SALESMAN</option>
                <option value="18">CUSTOMER CODE</option>
            </select>
            <input type="text" id="filter-input" placeholder="Type to filter...">

            <input type="date" id="from-date">

            <label for="to-date">To:</label>
            <input type="date" id="to-date">
            <button class="clear-filters" id="clear-filters">Clear</button>


            <!-- Download buttons -->
            <button id="download-report" class="btn btn-primary">Download Report (DOCX)</button>
        </div>
    </div>
    <table id="testRecords">
        <thead>
            <tr>
                <th>DATE</th>
                <th>PN</th>
				<th>PARTS READY DATE </th>
                <th>DRAW NO</th>
                <th>NO/CELL</th>
                <th>CUSTOMER</th>
                <th>QTY</th>
                <th>AV</th>
                <th>ESTIMATED TIME (Q x AV)</th>
                <th>Total Hours worked</th>
                <th>UNIT PRICE</th>
                <th>REMAINING TIME</th>
                <th>TEST TIME</th>
                <th>ORDER NO</th>
                <th>BILL PRICE</th>
                <th>PROFIT</th>
                <th>Comment</th>
                <th>STOCK CODE</th>
                <th>PICTURE</th>
                <th>SALESMAN</th>
                <th>CUSTOMER CODE</th>
                <th>Hours worked</th>
                <!-- Dynamic staff columns will be added here -->
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div id="imageModal">
        <span class="close">&times;</span>
        <img class="modal-content" id="modalImage">
    </div>

    


    <script src="clock.js"></script>
    <script>
        let isEditMode = false;
        // Load records on page load
        document.addEventListener('DOMContentLoaded', loadTestRecords);
        let currentCommentPn = '';


        async function loadTestRecords() {
            try {
                const response = await fetch(`${backendBaseUrl}/Products_test_records`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const records = await response.json();
                renderRecords(records);
            } catch (error) {
                console.error('Error fetching test records:', error);
                alert(`Failed to load test records. Error: ${error.message}`);
            }
        }

        async function renderRecords(records) {
            const tableBody = document.querySelector('#testRecords tbody');
            const tableHead = document.querySelector('#testRecords thead');
            tableBody.innerHTML = '';
            tableHead.innerHTML = '';


            // Add static columns to the table header
            const staticColumns = `
                <th>Actions</th>
                <th>DATE</th>
                <th>PN</th>
				<th>PARTS READY DATE </th>
                <th>DRAW NO</th>
                <th>NO/CELL</th>
                <th>CUSTOMER</th>
                <th>QTY</th>
                <th>AV</th>
                <th>ESTIMATED TIME</th>
                <th>TOTAL HOURS WORKED</th>
                <th>UNIT PRICE</th>
                <th>REMAINING TIME</th>
                <th>TEST TIME</th>
                <th>ORDER NO</th>
                <th>BILL PRICE</th>
                <th id="profitHeader" data-bs-toggle="tooltip" data-bs-placement="top" title="PROFIT = (UNIT Price * Qty)-(Total labor cost)-(Bill$ * Qty)">PROFIT</th>
                <th>Comment</th>
                <th>STOCK CODE</th>
                <th>PICTURE</th>
                <th>SALESMAN</th>
                <th>CUSTOMER CODE</th>
            `;
            tableHead.innerHTML = `<tr>${staticColumns}</tr>`;

            // Collect all unique staff names
            const allStaff = new Set();
            records.forEach(record => {
                const staffDetails = JSON.parse(record.staff_details || '{}');
                Object.keys(staffDetails).forEach(staffName => {
                    allStaff.add(staffName);
                });
            });

            // Add staff-specific columns to the table header
            const staffNames = Array.from(allStaff);
            staffNames.forEach(staffName => {
                if (!staffName.includes('QC')) {
                    const thWorkedHours = document.createElement('th');
                    thWorkedHours.textContent = `${staffName} (Hours Worked)`;
                    tableHead.querySelector('tr').appendChild(thWorkedHours);
                }
            });

            staffNames.forEach(staffName => {
                if (!staffName.includes('QC')) {
                    const thSaveTime = document.createElement('th');
                    thSaveTime.textContent = `${staffName} (Save Time)`;
                    tableHead.querySelector('tr').appendChild(thSaveTime);
                }
            });

            // Populate the table rows
            records.forEach(record => {
                const row = document.createElement('tr');
                row.setAttribute('data-pn', record.PN); // Add unique identifier

                if (record.profit < 0) {
                    row.style.backgroundColor = 'darkred';
                    row.style.color = 'white';
                }

                // Populate static columns
                row.innerHTML = `
                    <td>
                        <button class="edit-row-btn" onclick="startEdit('${record.PN}')">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                    </td>
                    <td>${record.date || ''}</td>
                    <td>${record.PN || ''}</td>
					<td>${record["PLAN READY DATE"] || ''}</td>
                    <td>${record.draw_no || ''}</td>
                    <td>${record.cells || ''}</td>
                    <td>${record.customer || ''}</td>
                    <td>${record.qty || 0}</td>
                    <td>${record.av || 0}</td>
                    <td>${record.estimated_time || 0}</td>
                    <td>${record.total_time || 0}</td>
                    <td>$${record.unit_price || 0}</td>
                    <td>${record.remaining_time || 0}</td>
                    <td>${record.test_time || ''}</td>
                    <td>${record.order_no || ''}</td>
                    <td>$${record.bill_price || 0}</td>
                    <td>$${record.profit || 0}</td>
                    <td>${record.comment || ''}</td>
                    <td>${record.stock_code || ''}</td>
                    <td class="pdf-cell">
                        ${parseInt(record.has_pdf) === 1 ?
                        `<a href="${backendBaseUrl}/get-pdf?pn=${record.PN}" class="pdf-link" target="_blank">${record.pdf_name || 'View PDF'}</a>` :
                        `<input type="file" onchange="uploadPDF('${record.PN}', this)">`
                    }
                    </td>
                    <td>${record.salesman || ''}</td>
                    <td>${record.customer_code || ''}</td>
                `;

                // Add staff-specific data
                const staffDetails = JSON.parse(record.staff_details || '{}');

                // Add worked hours for all staff first
                staffNames.forEach(staffName => {
                    if (!staffName.includes('QC')) {
                        const workedHoursCell = document.createElement('td');
                        workedHoursCell.textContent = staffDetails[staffName]?.worked_hours || '';
                        row.appendChild(workedHoursCell);
                    }
                });

                // Add save time for all staff next
                staffNames.forEach(staffName => {
                    if (!staffName.includes('QC')) {
                        const saveTimeCell = document.createElement('td');
                        saveTimeCell.textContent = staffDetails[staffName]?.save_time || '';
                        row.appendChild(saveTimeCell);
                    }
                });

                tableBody.appendChild(row);
            });
        }


        //Edit Table function
        let currentEditRow = null;

        function startEdit(pn) {
            const row = document.querySelector(`tr[data-pn="${pn}"]`);
            if (!row) return;

            currentEditRow = row;
            const cells = row.querySelectorAll('td:not(:first-child)'); // Skip the Actions column

            cells.forEach((cell, index) => {
                const value = cell.textContent.trim();
                const columnName = document.querySelector(`#testRecords thead tr th:nth-child(${index + 2})`).textContent;

                // Remove the `$` symbol for editable fields
                const cleanValue = value.startsWith('$') ? value.slice(1) : value;

                cell.innerHTML = `<input type="text" value="${cleanValue}" data-column="${columnName}">`;
            });

            const editBtn = row.querySelector('.edit-row-btn');
            editBtn.innerHTML = 'Save';
            editBtn.onclick = () => saveEdit(pn);
        }

        async function saveEdit(pn) {
            const row = currentEditRow;
            const inputs = row.querySelectorAll('input');
            const updates = {};

            // Gather new values
            inputs.forEach(input => {
                const colName = input.dataset.column;
                const normalizedCol = colName.replace(/\s+/g, '_').toLowerCase();
                let value = input.value.trim();
                if (value.startsWith('$')) value = value.slice(1);
                updates[normalizedCol] = value;
            });

            try {
                const response = await fetch(`${backendBaseUrl}/update-test-record`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pn, updates })
                });

                if (!response.ok) throw new Error("Failed to update record");
                alert("Updated successfully!");

                // Update the cells in the row (skip the "Actions" column)
                Object.values(updates).forEach((value, idx) => {
                    // cells[0] is the "Actions" column
                    row.cells[idx + 1].textContent = value;
                });

                // Restore Edit button
                const editBtn = row.querySelector('.edit-row-btn');
                editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
                editBtn.onclick = () => startEdit(pn);
                // *** Highlight the row ***
                row.classList.add('row-edited');

            } catch (error) {
                console.error(error);
                alert("Update failed: " + error.message);
            }
        }



        async function uploadPDF(pn, input) {
            const file = input.files[0];
            if (!file) {
                alert('Please select a PDF file first.');
                return;
            }

            // Validate file type
            if (file.type !== 'application/pdf') {
                alert('Only PDF files are allowed.');
                input.value = ''; // Clear the file input
                return;
            }

            // Validate file size (5MB max)
            if (file.size > 10 * 1024 * 1024) {
                alert('PDF file too large (max 10MB allowed)');
                input.value = '';
                return;
            }

            const formData = new FormData();
            formData.append('pn', pn);
            formData.append('file', file);

            try {
                const response = await fetch(`${backendBaseUrl}/upload-test-pdf`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || 'Failed to upload PDF');
                }

                const result = await response.json();

                // Success - dynamically update the row
                const row = document.querySelector(`tr[data-pn="${pn}"]`);
                const pdfCell = row.querySelector('.pdf-cell');
                pdfCell.innerHTML = `<a href="${backendBaseUrl}/get-pdf?pn=${pn}" class="pdf-link" target="_blank">${file.name}</a>`;
                alert('PDF uploaded successfully!');
            } catch (error) {
                console.error('Upload failed:', error);
                alert(`Upload failed: ${error.message}`);
                input.value = ''; // Reset on failure
            }
        }

        async function updateTestTime(pn, hours) {
            try {
                await fetch('/update-test-time', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pn: pn,
                        test_time: parseFloat(hours)
                    })
                });
            } catch (error) {
                console.error('Update failed:', error);
                alert('Failed to update test time');
            }
        }


        // Image modal functions
        function showImage(img) {
            document.getElementById('modalImage').src = img.src;
            document.getElementById('imageModal').style.display = 'block';
        }

        document.querySelector('.close').onclick = function () {
            document.getElementById('imageModal').style.display = 'none';
        };



        // Filter functionality
        document.addEventListener('DOMContentLoaded', () => {
            const filterColumn = document.getElementById('filter-column');
            const filterInput = document.getElementById('filter-input');
            const clearFiltersBtn = document.getElementById('clear-filters');
            const table = document.getElementById('testRecords');
            const tbody = table.querySelector('tbody');

            // Filter table rows based on input
            function filterTable() {
                const columnIndex = filterColumn.value === 'all' ? -1 : parseInt(filterColumn.value);
                const filterValue = filterInput.value.toLowerCase();
                const fromDate = document.getElementById('from-date').value;
                const toDate = document.getElementById('to-date').value;

                const rows = tbody.querySelectorAll('tr');

                rows.forEach(row => {
                    let matchFound = false;
                    const cells = row.querySelectorAll('td');
                    const dateCell = cells[1].textContent; // Assuming date is in first column

                    // Apply date filter first
                    let dateMatch = true;
                    if (fromDate || toDate) {
                        const rowDate = new Date(dateCell);
                        const fromDateObj = fromDate ? new Date(fromDate) : null;
                        const toDateObj = toDate ? new Date(toDate) : null;

                        if (fromDateObj && rowDate < fromDateObj) {
                            dateMatch = false;
                        }
                        if (toDateObj && rowDate > toDateObj) {
                            dateMatch = false;
                        }
                    }

                    // Only apply text filter if date matches
                    if (dateMatch) {
                        if (columnIndex === -1) { // Search all columns
                            cells.forEach(cell => {
                                if (cell.textContent.toLowerCase().includes(filterValue)) {
                                    matchFound = true;
                                }
                            });
                        } else if (columnIndex < cells.length) { // Search specific column
                            matchFound = cells[columnIndex].textContent.toLowerCase().includes(filterValue);
                        }
                    }

                    row.style.display = (dateMatch && matchFound) ? '' : 'none';
                });
            }


            // Clear filters
            function clearFilters() {
                filterColumn.value = 'all';
                filterInput.value = '';
                document.getElementById('from-date').value = '';
                document.getElementById('to-date').value = '';
                filterTable();
            }


            // Attach event listeners
            filterInput.addEventListener('input', filterTable);
            filterColumn.addEventListener('change', filterTable);
            clearFiltersBtn.addEventListener('click', clearFilters);
            document.getElementById('from-date').addEventListener('change', filterTable);
            document.getElementById('to-date').addEventListener('change', filterTable);
        });


        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i]);
        }


        // refresh pdf status
        async function refreshPDFStatus(pn) {
            try {
                const response = await fetch(`${backendBaseUrl}/refresh-pdf-status?pn=${pn}`);
                if (!response.ok) throw new Error('Refresh failed');
                loadTestRecords();
            } catch (error) {
                console.error('Refresh error:', error);
                alert('Failed to refresh PDF status');
            }
        }




        



        // Modified getFilteredData function to include date and staff filters
        function getFilteredData() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const staffFilter = document.getElementById('staff-filter').value;

            const filteredRows = [];
            const allRows = document.querySelectorAll('#testRecords tbody tr');

            allRows.forEach(row => {
                const rowDate = row.querySelector('td:nth-child(1)').textContent.trim(); // Assuming date is first column
                const staffCells = row.querySelectorAll('td[data-staff]'); // Cells with staff data

                // Check date range
                const dateInRange = (!startDate || !endDate ||
                    (rowDate >= startDate && rowDate <= endDate));

                // Check staff filter
                let staffMatch = !staffFilter;
                if (staffFilter) {
                    staffCells.forEach(cell => {
                        if (cell.textContent.includes(staffFilter)) {
                            staffMatch = true;
                        }
                    });
                }

                if (dateInRange && staffMatch) {
                    const rowData = {};
                    const cells = row.querySelectorAll('td');
                    const headers = document.querySelectorAll('#testRecords thead th');

                    cells.forEach((cell, index) => {
                        const header = headers[index].textContent.trim();
                        rowData[header] = cell.textContent.trim();
                    });

                    filteredRows.push(rowData);
                }
            });

            return filteredRows;
        }




        document.addEventListener('DOMContentLoaded', function () {
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl)
            });
        });


        // Download report button functionality

        document.getElementById('download-report').addEventListener('click', async function () {
            try {
                const fromDate = document.getElementById('from-date').value;
                const toDate = document.getElementById('to-date').value;

                if (!fromDate && !toDate) {
                    alert('Please select at least one date (From or To)');
                    return;
                }

                // Show loading indicator
                this.disabled = true;
                this.textContent = 'Generating Report...';

                // Get filtered data
                const response = await fetch(`${backendBaseUrl}/Products_test_records`);
                const allRecords = await response.json();

                // Filter records by date range
                const filteredRecords = allRecords.filter(record => {
                    const recordDate = new Date(record.date);
                    const fromDateObj = fromDate ? new Date(fromDate) : null;
                    const toDateObj = toDate ? new Date(toDate) : null;

                    let dateMatch = true;
                    if (fromDateObj && recordDate < fromDateObj) {
                        dateMatch = false;
                    }
                    if (toDateObj && recordDate > toDateObj) {
                        dateMatch = false;
                    }
                    return dateMatch;
                });

                if (filteredRecords.length === 0) {
                    alert('No records found for the selected date range');
                    return;
                }

                // Generate DOCX report
                await generateDocxReport(filteredRecords, fromDate, toDate);

            } catch (error) {
                console.error('Error generating report:', error);
                alert('Failed to generate report: ' + error.message);
            } finally {
                // Reset button
                this.disabled = false;
                this.textContent = 'Download Report (DOCX)';
            }
        });

        async function generateDocxReport(records, fromDate, toDate) {
            const { Document, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, AlignmentType } = docx;

            // Calculate summary statistics
            const summary = calculateSummaryStatistics(records);
            const staffSummary = calculateStaffStatistics(records);

            // Create document
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: [
                        // Report title and metadata (same as before)
                        new Paragraph({
                            text: "Production Test Records Report",
                            heading: HeadingLevel.HEADING_1,
                            alignment: AlignmentType.CENTER
                        }),
                        new Paragraph({
                            text: `Date Range: ${fromDate || 'Start'} to ${toDate || 'End'}`,
                            alignment: AlignmentType.CENTER,
                            spacing: { after: 200 }
                        }),
                        new Paragraph({
                            text: `Total Records: ${records.length}`,
                            alignment: AlignmentType.LEFT,
                            spacing: { after: 100 }
                        }),

                        // Records table
                        createRecordsTable(records),

                        // Staff performance section
                        new Paragraph({
                            text: "Staff Performance",
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 400, after: 200 }
                        }),
                        createStaffTable(staffSummary),

                        // Summary statistics (same as before)
                        new Paragraph({
                            text: "Summary Statistics",
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 400, after: 200 }
                        }),
                        createSummaryTable(summary),

                        // Footer note
                        new Paragraph({
                            text: "Report generated on " + new Date().toLocaleDateString(),
                            alignment: AlignmentType.RIGHT,
                            spacing: { before: 400 }
                        })
                    ]
                }]
            });

            // Generate and download the document
            const blob = await docx.Packer.toBlob(doc);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Production_Test_Records_${fromDate || ''}_${toDate || ''}.docx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }


        function createRecordsTable(records) {
            const { Table, TableRow, TableCell, Paragraph, TextRun, AlignmentType, WidthType, BorderStyle } = docx;

            // Add new columns to the header
            const headerTitles = [
                "Date", "PN", "Customer", "Qty", "Unit Price", "Bill Price", "StaffNames", "Remaining Time", "Profit", "Status"

            ];

            // Create table header with styling
            const headerRow = new TableRow({
                children: headerTitles.map(text =>
                    new TableCell({
                        children: [new Paragraph({
                            children: [new TextRun({ text, bold: true })],
                            alignment: AlignmentType.CENTER
                        })],
                        shading: {
                            fill: "#00009e"
                        },
                        borders: {
                            top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                            bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                            left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                            right: { style: BorderStyle.SINGLE, size: 1, color: "000000" }
                        }
                    })
                )
            });

            // Create table rows
            const rows = records.map(record => {
                const profit = record.profit || 0;
                const status = profit >= 0 ? "Profitable" : "Loss";
                // Get staff names except QC
                let staffNames = "";
                try {
                    const staffDetails = JSON.parse(record.staff_details || '{}');
                    staffNames = Object.keys(staffDetails)
                        .filter(name => !name.toLowerCase().includes('qc'))
                        .join('/');
                } catch (e) {
                    staffNames = "";
                }

                return new TableRow({
                    children: [
                        new TableCell({ children: [new Paragraph(record.date || "")] }),
                        new TableCell({ children: [new Paragraph(record.PN || "")] }),
                        new TableCell({ children: [new Paragraph(record.customer || "")] }),
                        new TableCell({ children: [new Paragraph((record.qty || 0).toString())] }),
                        new TableCell({ children: [new Paragraph(`$${(record.unit_price || 0).toFixed(2)}`)] }),
                        new TableCell({ children: [new Paragraph(`$${(record.bill_price || 0).toFixed(2)}`)] }),
                        // New column: StaffNames
                        new TableCell({ children: [new Paragraph(staffNames)] }),
                        // New column: Remaining Time
                        new TableCell({ children: [new Paragraph((record.remaining_time || "").toString())] }),
                        new TableCell({
                            children: [new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `$${profit.toFixed(2)}`,
                                        color: profit >= 0 ? "00FF00" : "FF0000",
                                        bold: true
                                    })
                                ]
                            })]
                        }),
                        new TableCell({
                            children: [new Paragraph({
                                children: [
                                    new TextRun({
                                        text: status,
                                        color: profit >= 0 ? "00FF00" : "FF0000",
                                        bold: true
                                    })
                                ]
                            })]
                        })
                    ]
                });
            });

            // Create the table
            return new Table({
                rows: [headerRow, ...rows],
                width: { size: 100, type: "pct" },
                columnWidths: [15, 15, 20, 10, 10, 10, 10, 10]
            });
        }


        function createSummaryTable(summary) {
            const { Table, TableRow, TableCell, Paragraph, TextRun, AlignmentType } = docx;

            const formatCurrency = (value) => `$${value.toFixed(2)}`;

            return new Table({
                rows: [
                    // Header row
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Metric")] }),
                            new TableCell({ children: [new Paragraph("Value")] })
                        ],
                        tableHeader: true
                    }),

                    // Data rows
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Total Records")] }),
                            new TableCell({ children: [new Paragraph(summary.totalRecords.toString())] })
                        ]
                    }),
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Total Quantity")] }),
                            new TableCell({ children: [new Paragraph(summary.totalQty.toString())] })
                        ]
                    }),
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Total Profit")] }),
                            new TableCell({
                                children: [new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: formatCurrency(summary.totalProfit),
                                            color: summary.totalProfit >= 0 ? "00FF00" : "FF0000",
                                            bold: true
                                        })
                                    ]
                                })]
                            })
                        ]
                    }),
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Profitable Jobs")] }),
                            new TableCell({ children: [new Paragraph(`${summary.profitableJobs} (${summary.profitPercentage}%)`)] })
                        ]
                    }),
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Loss Jobs")] }),
                            new TableCell({ children: [new Paragraph(summary.lossJobs.toString())] })
                        ]
                    }),

                ],
                width: { size: 50, type: "pct" },
                columnWidths: [30, 20]
            });
        }



        function calculateSummaryStatistics(records) {
            const totalQty = records.reduce((sum, record) => sum + (record.qty || 0), 0);
            const totalProfit = records.reduce((sum, record) => sum + (record.profit || 0), 0);
            const avgProfit = totalProfit / records.length;
            const profitableJobs = records.filter(r => (r.profit || 0) >= 0).length;
            const lossJobs = records.length - profitableJobs;

            return {
                totalRecords: records.length,
                totalQty,
                totalProfit,
                profitableJobs,
                lossJobs,
                profitPercentage: (profitableJobs / records.length * 100).toFixed(1)
            };
        }

        function calculateStaffStatistics(records) {
            const staffMap = new Map();

            // Process all records to aggregate staff data
            records.forEach(record => {
                try {
                    const staffDetails = JSON.parse(record.staff_details || '{}');

                    Object.entries(staffDetails).forEach(([staffName, details]) => {
                        if (!staffMap.has(staffName)) {
                            staffMap.set(staffName, {
                                totalHours: 0,
                                totalSaveTime: 0,
                                jobsWorked: 0
                            });
                        }

                        const staffData = staffMap.get(staffName);
                        staffData.totalHours += parseFloat(details.worked_hours) || 0;
                        staffData.totalSaveTime += parseFloat(details.save_time) || 0;
                        staffData.jobsWorked += 1;
                    });
                } catch (e) {
                    console.error('Error parsing staff details:', e);
                }
            });

            // Convert to array and calculate averages
            return Array.from(staffMap.entries()).map(([name, data]) => ({
                name,
                totalHours: data.totalHours,
                totalSaveTime: data.totalSaveTime,
                avgHoursPerJob: data.totalHours / data.jobsWorked,
                avgSaveTimePerJob: data.totalSaveTime / data.jobsWorked,
                jobsWorked: data.jobsWorked
            })).sort((a, b) => b.totalHours - a.totalHours); // Sort by most hours worked
        }

        function createStaffTable(staffData) {
            const { Table, TableRow, TableCell, Paragraph, TextRun } = docx;

            return new Table({
                rows: [
                    // Header row
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("Staff Name")] }),
                            new TableCell({ children: [new Paragraph("Total Hours")] }),
                            new TableCell({ children: [new Paragraph("Total Save Time")] }),
                            new TableCell({ children: [new Paragraph("Avg Hours/Job")] }),
                            new TableCell({ children: [new Paragraph("Avg Save Time/Job")] }),
                            new TableCell({ children: [new Paragraph("Jobs Worked")] })
                        ],
                        tableHeader: true
                    }),

                    // Data rows
                    ...staffData.map(staff => (
                        new TableRow({
                            children: [
                                new TableCell({ children: [new Paragraph(staff.name)] }),
                                new TableCell({ children: [new Paragraph(staff.totalHours.toFixed(2))] }),
                                new TableCell({ children: [new Paragraph(staff.totalSaveTime.toFixed(2))] }),
                                new TableCell({ children: [new Paragraph(staff.avgHoursPerJob.toFixed(2))] }),
                                new TableCell({ children: [new Paragraph(staff.avgSaveTimePerJob.toFixed(2))] }),
                                new TableCell({ children: [new Paragraph(staff.jobsWorked.toString())] })
                            ]
                        })
                    )),

                    // Footer row with totals
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph("TOTAL")] }),
                            new TableCell({
                                children: [new Paragraph(
                                    staffData.reduce((sum, s) => sum + s.totalHours, 0).toFixed(2)
                                )]
                            }),
                            new TableCell({
                                children: [new Paragraph(
                                    staffData.reduce((sum, s) => sum + s.totalSaveTime, 0).toFixed(2)
                                )]
                            }),
                            new TableCell({ children: [new Paragraph("")] }),
                            new TableCell({ children: [new Paragraph("")] }),
                            new TableCell({
                                children: [new Paragraph(
                                    staffData.reduce((sum, s) => sum + s.jobsWorked, 0).toString()

                                )]
                            })
                        ]
                    })
                ],
                width: { size: 100, type: "pct" },
                columnWidths: [20, 15, 15, 15, 15, 15]
            });
        }






    </script>
</body>

</html>